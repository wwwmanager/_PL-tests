# Руководство по тестированию

Этот документ описывает стратегию, инструменты и лучшие практики для тестирования приложения "Путевые листы".

## 1. Философия тестирования

Учитывая архитектуру приложения (полностью клиентское, offline-first, сложная бизнес-логика в браузере), тестирование играет ключевую роль в обеспечении его надежности и корректности.

**Основные цели:**
1.  **Гарантировать корректность бизнес-логики**: Проверять правильность расчетов, переходов статусов, управления бланками и других критических операций.
2.  **Предотвращать регрессии**: Убедиться, что новые изменения не ломают существующий функционал.
3.  **Обеспечить стабильность**: Повысить уверенность в качестве кода при рефакторинге и добавлении новых функций.

## 2. Инструменты и настройка

- **Фреймворк**: [Vitest](https://vitest.dev/) — современный, быстрый и совместимый с Vite фреймворк для тестирования.
- **Среда выполнения**: Тесты выполняются в среде `node`, как указано в `vitest.config.ts`. Это означает, что в тестах нет доступа к DOM (объектам `window`, `document` и т.д.), что идеально подходит для тестирования чистой бизнес-логики.

Конфигурация в `vitest.config.ts` настроена на поиск файлов, заканчивающихся на `.test.ts` или `.spec.ts`, по всему проекту.

## 3. Виды тестов

### Модульные тесты (Unit Tests)

Это основной вид тестов в проекте. Они проверяют изолированные части функционала (отдельные функции).

- **Что тестировать**: Функции из `services/mockApi.ts`, `services/auditLog.ts`, `services/routeParserService.ts` и другие утилиты.
- **Принцип**: Каждый тест должен быть независимым. Для этого используется хук `beforeEach`, чтобы сбросить состояние `mockApi` и моки перед каждым запуском. Зависимости, такие как `storage.ts`, мокируются для полной изоляции.

**Пример (из `services/mockApi.test.ts`):**

```typescript
// services/mockApi.test.ts

// Мокируем зависимости вверху файла
vi.mock('./storage', () => ({
  loadJSON: vi.fn().mockResolvedValue([]),
  saveJSON: vi.fn().mockResolvedValue(undefined),
}));

describe('Blank Management', () => {
  beforeEach(() => {
    // Сбрасываем состояние перед каждым тестом
    resetMockApiState();
    vi.clearAllMocks();
  });

  it('should materialize a batch of blanks', async () => {
    // 1. Arrange (Подготовка)
    await createBlankBatch({ organizationId: 'org-test', series: 'BB', startNumber: 10, endNumber: 15 });
    
    // 2. Act (Действие)
    const result = await materializeBatch('batch-1');

    // 3. Assert (Проверка)
    expect(result.created).toBe(6);
    const blanks = await getBlanks();
    expect(blanks.length).toBe(6);
    expect(blanks[0].status).toBe('available');
  });
});
```

Аналогичные тесты существуют для `services/auditBusiness.test.ts` (проверка логики бизнес-журнала) и `services/routeParserService.test.ts` (проверка парсера файлов отчетов).

### Интеграционные тесты (на уровне сервисов)

Эти тесты проверяют взаимодействие нескольких функций для выполнения полноценного пользовательского сценария. В нашем контексте это не UI-тесты, а тесты, проверяющие сложные цепочки вызовов внутри `mockApi.ts`.

- **Что тестировать**: Полный жизненный цикл сущностей (например, создание, проведение и корректировка путевого листа), процессы импорта, выдачи бланков и т.д.
- **Принцип**: Тест имитирует последовательность действий, которые привели бы к конечному результату в интерфейсе, и проверяет итоговое состояние системы.

**Пример (из `services/mockApi.test.ts`):**

```typescript
// services/mockApi.test.ts

describe('Full Scenario: Waybill Lifecycle', () => {
  it('should correctly handle a waybill from creation to posting', async () => {
    // 1. Создание водителя, ТС, пачки бланков
    // 2. Выдача бланка водителю
    // 3. Создание путевого листа (проверка, что бланк зарезервировался)
    // 4. Проведение путевого листа
    // 5. Проверка, что статус ПЛ изменился, а статус бланка стал 'used'
  });
});
```

### E2E (End-to-End) тесты (Перспектива)

На данный момент E2E тесты не настроены. Они требуют запуска браузера и имитации действий пользователя (клики, ввод текста).

- **Что тестировать**: Ключевые пользовательские сценарии от начала до конца. Например: "Пользователь заходит в справочник ТС, нажимает 'Добавить', заполняет форму, сохраняет и видит новую запись в таблице".
- **Инструменты**: Для этого можно будет внедрить фреймворки, такие как **Playwright** или **Cypress**.

## 4. Как писать тесты

1.  **Расположение**: Создавайте тестовые файлы рядом с тестируемыми модулями. Например, для `services/mockApi.ts` тест находится в `services/mockApi.test.ts`.
2.  **Структура**: Используйте `describe` для группировки тестов по функционалу, и `it` для описания конкретного проверяемого поведения.
3.  **Изоляция**: Всегда используйте `beforeEach` для очистки состояния и моков. Это предотвращает влияние одного теста на другой.
4.  **AAA (Arrange, Act, Assert)**: Структурируйте каждый тест по этому принципу:
    -   **Arrange**: Подготовка данных, настройка моков.
    -   **Act**: Вызов тестируемой функции.
    -   **Assert**: Проверка результата с помощью `expect`.

## 5. Что тестировать? (Приоритеты)

1.  **Критическая бизнес-логика**: В первую очередь покрывайте тестами самую сложную и важную логику:
    -   `services/mockApi.ts`: статусные модели, учет бланков, расчеты.
    -   `services/auditLog.ts`, `services/auditBusiness.ts`: логика журнала аудита.
    -   `services/routeParserService.ts`: логика парсинга файлов.
2.  **"Счастливый путь" (Happy Path)**: Убедитесь, что основной функционал работает, как ожидается, при корректных данных.
3.  **Крайние случаи (Edge Cases)**: Проверяйте поведение системы на невалидных данных:
    -   Неверные переходы статусов.
    -   Попытка выдать уже выданный бланк.
    -   Сохранение формы с пустыми обязательными полями.
    -   Нулевые или отрицательные значения там, где они не допускаются.
4.  **Регрессии**: При исправлении бага напишите тест, который воспроизводит этот баг. Этот тест останется в системе и не позволит ошибке появиться снова.

## 6. Запуск тестов

Для запуска тестов в консоли выполните команду:

```bash
npx vitest
```

Для запуска в режиме наблюдения (автоматический перезапуск при изменении файлов):

```bash
npx vitest watch
```